// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
                                                                                                                        #error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
                                                                                                                        #error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace elegram {

// Internal implementation detail -- do not call these.
  void protobuf_AddDesc_messages_2eproto();
  void protobuf_AssignDesc_messages_2eproto();
  void protobuf_ShutdownFile_messages_2eproto();

  class AddContactRequest;
  class AllMyChatsRequest;
  class AllMyContactsRequest;
  class Chat;
  class ChatsResponse;
  class Contact;
  class ContactsResponse;
  class LengthPrefix;
  class LoginRequest;
  class MessageToRecieve;
  class MessageToSend;
  class MessagesRequest;
  class MessagesResponse;
  class RegisterRequest;
  class Request;
  class Response;
  class SendMessageRequest;
  class StatusResponse;
  class WrappedMessage;

  enum StatusResponse_RESULT {
    StatusResponse_RESULT_ACCEPTED = 0,
    StatusResponse_RESULT_REJECTED = 1,
    StatusResponse_RESULT_StatusResponse_RESULT_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
    StatusResponse_RESULT_StatusResponse_RESULT_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
  };
  bool StatusResponse_RESULT_IsValid(int value);
  const StatusResponse_RESULT StatusResponse_RESULT_RESULT_MIN = StatusResponse_RESULT_ACCEPTED;
  const StatusResponse_RESULT StatusResponse_RESULT_RESULT_MAX = StatusResponse_RESULT_REJECTED;
  const int StatusResponse_RESULT_RESULT_ARRAYSIZE = StatusResponse_RESULT_RESULT_MAX + 1;

  const ::google::protobuf::EnumDescriptor *StatusResponse_RESULT_descriptor();
  inline const ::std::string &StatusResponse_RESULT_Name(StatusResponse_RESULT value) {
      return ::google::protobuf::internal::NameOfEnum(
          StatusResponse_RESULT_descriptor(), value);
  }
  inline bool StatusResponse_RESULT_Parse(
      const ::std::string &name, StatusResponse_RESULT *value) {
      return ::google::protobuf::internal::ParseNamedEnum<StatusResponse_RESULT>(
          StatusResponse_RESULT_descriptor(), name, value);
  }
// ===================================================================

  class RegisterRequest
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.RegisterRequest) */ {
   public:
    RegisterRequest();
    virtual ~RegisterRequest();

    RegisterRequest(const RegisterRequest &from);

    inline RegisterRequest &operator=(const RegisterRequest &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const RegisterRequest &default_instance();

    void Swap(RegisterRequest *other);

    // implements Message ----------------------------------------------

    inline RegisterRequest *New() const { return New(NULL); }

    RegisterRequest *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const RegisterRequest &from);
    void MergeFrom(const RegisterRequest &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RegisterRequest *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string name = 1;
    void clear_name();
    static const int kNameFieldNumber = 1;
    const ::std::string &name() const;
    void set_name(const ::std::string &value);
    void set_name(const char *value);
    void set_name(const char *value, size_t size);
    ::std::string *mutable_name();
    ::std::string *release_name();
    void set_allocated_name(::std::string *name);

    // optional string email = 2;
    void clear_email();
    static const int kEmailFieldNumber = 2;
    const ::std::string &email() const;
    void set_email(const ::std::string &value);
    void set_email(const char *value);
    void set_email(const char *value, size_t size);
    ::std::string *mutable_email();
    ::std::string *release_email();
    void set_allocated_email(::std::string *email);

    // optional string password = 3;
    void clear_password();
    static const int kPasswordFieldNumber = 3;
    const ::std::string &password() const;
    void set_password(const ::std::string &value);
    void set_password(const char *value);
    void set_password(const char *value, size_t size);
    ::std::string *mutable_password();
    ::std::string *release_password();
    void set_allocated_password(::std::string *password);

    // @@protoc_insertion_point(class_scope:elegram.RegisterRequest)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static RegisterRequest *default_instance_;
  };
// -------------------------------------------------------------------

  class LoginRequest
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.LoginRequest) */ {
   public:
    LoginRequest();
    virtual ~LoginRequest();

    LoginRequest(const LoginRequest &from);

    inline LoginRequest &operator=(const LoginRequest &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const LoginRequest &default_instance();

    void Swap(LoginRequest *other);

    // implements Message ----------------------------------------------

    inline LoginRequest *New() const { return New(NULL); }

    LoginRequest *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const LoginRequest &from);
    void MergeFrom(const LoginRequest &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(LoginRequest *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string email = 1;
    void clear_email();
    static const int kEmailFieldNumber = 1;
    const ::std::string &email() const;
    void set_email(const ::std::string &value);
    void set_email(const char *value);
    void set_email(const char *value, size_t size);
    ::std::string *mutable_email();
    ::std::string *release_email();
    void set_allocated_email(::std::string *email);

    // optional string password = 2;
    void clear_password();
    static const int kPasswordFieldNumber = 2;
    const ::std::string &password() const;
    void set_password(const ::std::string &value);
    void set_password(const char *value);
    void set_password(const char *value, size_t size);
    ::std::string *mutable_password();
    ::std::string *release_password();
    void set_allocated_password(::std::string *password);

    // @@protoc_insertion_point(class_scope:elegram.LoginRequest)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static LoginRequest *default_instance_;
  };
// -------------------------------------------------------------------

  class AllMyChatsRequest
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.AllMyChatsRequest) */ {
   public:
    AllMyChatsRequest();
    virtual ~AllMyChatsRequest();

    AllMyChatsRequest(const AllMyChatsRequest &from);

    inline AllMyChatsRequest &operator=(const AllMyChatsRequest &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const AllMyChatsRequest &default_instance();

    void Swap(AllMyChatsRequest *other);

    // implements Message ----------------------------------------------

    inline AllMyChatsRequest *New() const { return New(NULL); }

    AllMyChatsRequest *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const AllMyChatsRequest &from);
    void MergeFrom(const AllMyChatsRequest &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AllMyChatsRequest *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:elegram.AllMyChatsRequest)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static AllMyChatsRequest *default_instance_;
  };
// -------------------------------------------------------------------

  class AllMyContactsRequest
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.AllMyContactsRequest) */ {
   public:
    AllMyContactsRequest();
    virtual ~AllMyContactsRequest();

    AllMyContactsRequest(const AllMyContactsRequest &from);

    inline AllMyContactsRequest &operator=(const AllMyContactsRequest &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const AllMyContactsRequest &default_instance();

    void Swap(AllMyContactsRequest *other);

    // implements Message ----------------------------------------------

    inline AllMyContactsRequest *New() const { return New(NULL); }

    AllMyContactsRequest *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const AllMyContactsRequest &from);
    void MergeFrom(const AllMyContactsRequest &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AllMyContactsRequest *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:elegram.AllMyContactsRequest)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static AllMyContactsRequest *default_instance_;
  };
// -------------------------------------------------------------------

  class MessagesRequest
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.MessagesRequest) */ {
   public:
    MessagesRequest();
    virtual ~MessagesRequest();

    MessagesRequest(const MessagesRequest &from);

    inline MessagesRequest &operator=(const MessagesRequest &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const MessagesRequest &default_instance();

    void Swap(MessagesRequest *other);

    // implements Message ----------------------------------------------

    inline MessagesRequest *New() const { return New(NULL); }

    MessagesRequest *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const MessagesRequest &from);
    void MergeFrom(const MessagesRequest &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(MessagesRequest *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint64 chat_id = 1;
    void clear_chat_id();
    static const int kChatIdFieldNumber = 1;
    ::google::protobuf::uint64 chat_id() const;
    void set_chat_id(::google::protobuf::uint64 value);

    // @@protoc_insertion_point(class_scope:elegram.MessagesRequest)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::uint64 chat_id_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static MessagesRequest *default_instance_;
  };
// -------------------------------------------------------------------

  class MessageToSend
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.MessageToSend) */ {
   public:
    MessageToSend();
    virtual ~MessageToSend();

    MessageToSend(const MessageToSend &from);

    inline MessageToSend &operator=(const MessageToSend &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const MessageToSend &default_instance();

    void Swap(MessageToSend *other);

    // implements Message ----------------------------------------------

    inline MessageToSend *New() const { return New(NULL); }

    MessageToSend *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const MessageToSend &from);
    void MergeFrom(const MessageToSend &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(MessageToSend *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint64 chat_id = 1;
    void clear_chat_id();
    static const int kChatIdFieldNumber = 1;
    ::google::protobuf::uint64 chat_id() const;
    void set_chat_id(::google::protobuf::uint64 value);

    // optional string text = 2;
    void clear_text();
    static const int kTextFieldNumber = 2;
    const ::std::string &text() const;
    void set_text(const ::std::string &value);
    void set_text(const char *value);
    void set_text(const char *value, size_t size);
    ::std::string *mutable_text();
    ::std::string *release_text();
    void set_allocated_text(::std::string *text);

    // @@protoc_insertion_point(class_scope:elegram.MessageToSend)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::uint64 chat_id_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static MessageToSend *default_instance_;
  };
// -------------------------------------------------------------------

  class SendMessageRequest
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.SendMessageRequest) */ {
   public:
    SendMessageRequest();
    virtual ~SendMessageRequest();

    SendMessageRequest(const SendMessageRequest &from);

    inline SendMessageRequest &operator=(const SendMessageRequest &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const SendMessageRequest &default_instance();

    void Swap(SendMessageRequest *other);

    // implements Message ----------------------------------------------

    inline SendMessageRequest *New() const { return New(NULL); }

    SendMessageRequest *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const SendMessageRequest &from);
    void MergeFrom(const SendMessageRequest &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SendMessageRequest *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .elegram.MessageToSend mesg = 1;
    bool has_mesg() const;
    void clear_mesg();
    static const int kMesgFieldNumber = 1;
    const ::elegram::MessageToSend &mesg() const;
    ::elegram::MessageToSend *mutable_mesg();
    ::elegram::MessageToSend *release_mesg();
    void set_allocated_mesg(::elegram::MessageToSend *mesg);

    // @@protoc_insertion_point(class_scope:elegram.SendMessageRequest)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::elegram::MessageToSend *mesg_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static SendMessageRequest *default_instance_;
  };
// -------------------------------------------------------------------

  class AddContactRequest
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.AddContactRequest) */ {
   public:
    AddContactRequest();
    virtual ~AddContactRequest();

    AddContactRequest(const AddContactRequest &from);

    inline AddContactRequest &operator=(const AddContactRequest &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const AddContactRequest &default_instance();

    void Swap(AddContactRequest *other);

    // implements Message ----------------------------------------------

    inline AddContactRequest *New() const { return New(NULL); }

    AddContactRequest *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const AddContactRequest &from);
    void MergeFrom(const AddContactRequest &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AddContactRequest *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string email = 1;
    void clear_email();
    static const int kEmailFieldNumber = 1;
    const ::std::string &email() const;
    void set_email(const ::std::string &value);
    void set_email(const char *value);
    void set_email(const char *value, size_t size);
    ::std::string *mutable_email();
    ::std::string *release_email();
    void set_allocated_email(::std::string *email);

    // @@protoc_insertion_point(class_scope:elegram.AddContactRequest)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static AddContactRequest *default_instance_;
  };
// -------------------------------------------------------------------

  class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.Request) */ {
   public:
    Request();
    virtual ~Request();

    Request(const Request &from);

    inline Request &operator=(const Request &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const Request &default_instance();

    enum MsgCase {
      kRegisterRequest = 1,
      kLoginRequest = 2,
      kChatsRequest = 3,
      kContactsRequest = 4,
      kMessagesRequest = 5,
      kSendMesgRequest = 6,
      kAddContactRequest = 7,
      MSG_NOT_SET = 0,
    };

    void Swap(Request *other);

    // implements Message ----------------------------------------------

    inline Request *New() const { return New(NULL); }

    Request *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const Request &from);
    void MergeFrom(const Request &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Request *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .elegram.RegisterRequest register_request = 1;
    bool has_register_request() const;
    void clear_register_request();
    static const int kRegisterRequestFieldNumber = 1;
    const ::elegram::RegisterRequest &register_request() const;
    ::elegram::RegisterRequest *mutable_register_request();
    ::elegram::RegisterRequest *release_register_request();
    void set_allocated_register_request(::elegram::RegisterRequest *register_request);

    // optional .elegram.LoginRequest login_request = 2;
    bool has_login_request() const;
    void clear_login_request();
    static const int kLoginRequestFieldNumber = 2;
    const ::elegram::LoginRequest &login_request() const;
    ::elegram::LoginRequest *mutable_login_request();
    ::elegram::LoginRequest *release_login_request();
    void set_allocated_login_request(::elegram::LoginRequest *login_request);

    // optional .elegram.AllMyChatsRequest chats_request = 3;
    bool has_chats_request() const;
    void clear_chats_request();
    static const int kChatsRequestFieldNumber = 3;
    const ::elegram::AllMyChatsRequest &chats_request() const;
    ::elegram::AllMyChatsRequest *mutable_chats_request();
    ::elegram::AllMyChatsRequest *release_chats_request();
    void set_allocated_chats_request(::elegram::AllMyChatsRequest *chats_request);

    // optional .elegram.AllMyContactsRequest contacts_request = 4;
    bool has_contacts_request() const;
    void clear_contacts_request();
    static const int kContactsRequestFieldNumber = 4;
    const ::elegram::AllMyContactsRequest &contacts_request() const;
    ::elegram::AllMyContactsRequest *mutable_contacts_request();
    ::elegram::AllMyContactsRequest *release_contacts_request();
    void set_allocated_contacts_request(::elegram::AllMyContactsRequest *contacts_request);

    // optional .elegram.MessagesRequest messages_request = 5;
    bool has_messages_request() const;
    void clear_messages_request();
    static const int kMessagesRequestFieldNumber = 5;
    const ::elegram::MessagesRequest &messages_request() const;
    ::elegram::MessagesRequest *mutable_messages_request();
    ::elegram::MessagesRequest *release_messages_request();
    void set_allocated_messages_request(::elegram::MessagesRequest *messages_request);

    // optional .elegram.SendMessageRequest send_mesg_request = 6;
    bool has_send_mesg_request() const;
    void clear_send_mesg_request();
    static const int kSendMesgRequestFieldNumber = 6;
    const ::elegram::SendMessageRequest &send_mesg_request() const;
    ::elegram::SendMessageRequest *mutable_send_mesg_request();
    ::elegram::SendMessageRequest *release_send_mesg_request();
    void set_allocated_send_mesg_request(::elegram::SendMessageRequest *send_mesg_request);

    // optional .elegram.AddContactRequest add_contact_request = 7;
    bool has_add_contact_request() const;
    void clear_add_contact_request();
    static const int kAddContactRequestFieldNumber = 7;
    const ::elegram::AddContactRequest &add_contact_request() const;
    ::elegram::AddContactRequest *mutable_add_contact_request();
    ::elegram::AddContactRequest *release_add_contact_request();
    void set_allocated_add_contact_request(::elegram::AddContactRequest *add_contact_request);

    MsgCase msg_case() const;
    // @@protoc_insertion_point(class_scope:elegram.Request)
   private:
    inline void set_has_register_request();
    inline void set_has_login_request();
    inline void set_has_chats_request();
    inline void set_has_contacts_request();
    inline void set_has_messages_request();
    inline void set_has_send_mesg_request();
    inline void set_has_add_contact_request();

    inline bool has_msg() const;
    void clear_msg();
    inline void clear_has_msg();

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    union MsgUnion {
      MsgUnion() {}
      ::elegram::RegisterRequest *register_request_;
      ::elegram::LoginRequest *login_request_;
      ::elegram::AllMyChatsRequest *chats_request_;
      ::elegram::AllMyContactsRequest *contacts_request_;
      ::elegram::MessagesRequest *messages_request_;
      ::elegram::SendMessageRequest *send_mesg_request_;
      ::elegram::AddContactRequest *add_contact_request_;
    } msg_;
    mutable int _cached_size_;
    ::google::protobuf::uint32 _oneof_case_[1];

    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static Request *default_instance_;
  };
// -------------------------------------------------------------------

  class StatusResponse
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.StatusResponse) */ {
   public:
    StatusResponse();
    virtual ~StatusResponse();

    StatusResponse(const StatusResponse &from);

    inline StatusResponse &operator=(const StatusResponse &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const StatusResponse &default_instance();

    void Swap(StatusResponse *other);

    // implements Message ----------------------------------------------

    inline StatusResponse *New() const { return New(NULL); }

    StatusResponse *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const StatusResponse &from);
    void MergeFrom(const StatusResponse &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StatusResponse *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    typedef StatusResponse_RESULT RESULT;
    static const RESULT ACCEPTED =
        StatusResponse_RESULT_ACCEPTED;
    static const RESULT REJECTED =
        StatusResponse_RESULT_REJECTED;
    static inline bool RESULT_IsValid(int value) {
        return StatusResponse_RESULT_IsValid(value);
    }
    static const RESULT RESULT_MIN =
        StatusResponse_RESULT_RESULT_MIN;
    static const RESULT RESULT_MAX =
        StatusResponse_RESULT_RESULT_MAX;
    static const int RESULT_ARRAYSIZE =
        StatusResponse_RESULT_RESULT_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor *
    RESULT_descriptor() {
        return StatusResponse_RESULT_descriptor();
    }
    static inline const ::std::string &RESULT_Name(RESULT value) {
        return StatusResponse_RESULT_Name(value);
    }
    static inline bool RESULT_Parse(const ::std::string &name,
                                    RESULT *value) {
        return StatusResponse_RESULT_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    // optional .elegram.StatusResponse.RESULT result = 1;
    void clear_result();
    static const int kResultFieldNumber = 1;
    ::elegram::StatusResponse_RESULT result() const;
    void set_result(::elegram::StatusResponse_RESULT value);

    // @@protoc_insertion_point(class_scope:elegram.StatusResponse)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    int result_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static StatusResponse *default_instance_;
  };
// -------------------------------------------------------------------

  class Chat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.Chat) */ {
   public:
    Chat();
    virtual ~Chat();

    Chat(const Chat &from);

    inline Chat &operator=(const Chat &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const Chat &default_instance();

    void Swap(Chat *other);

    // implements Message ----------------------------------------------

    inline Chat *New() const { return New(NULL); }

    Chat *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const Chat &from);
    void MergeFrom(const Chat &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Chat *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint64 chat_id = 1;
    void clear_chat_id();
    static const int kChatIdFieldNumber = 1;
    ::google::protobuf::uint64 chat_id() const;
    void set_chat_id(::google::protobuf::uint64 value);

    // optional string title = 2;
    void clear_title();
    static const int kTitleFieldNumber = 2;
    const ::std::string &title() const;
    void set_title(const ::std::string &value);
    void set_title(const char *value);
    void set_title(const char *value, size_t size);
    ::std::string *mutable_title();
    ::std::string *release_title();
    void set_allocated_title(::std::string *title);

    // @@protoc_insertion_point(class_scope:elegram.Chat)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::uint64 chat_id_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static Chat *default_instance_;
  };
// -------------------------------------------------------------------

  class ChatsResponse
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.ChatsResponse) */ {
   public:
    ChatsResponse();
    virtual ~ChatsResponse();

    ChatsResponse(const ChatsResponse &from);

    inline ChatsResponse &operator=(const ChatsResponse &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const ChatsResponse &default_instance();

    void Swap(ChatsResponse *other);

    // implements Message ----------------------------------------------

    inline ChatsResponse *New() const { return New(NULL); }

    ChatsResponse *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const ChatsResponse &from);
    void MergeFrom(const ChatsResponse &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ChatsResponse *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated .elegram.Chat chats = 1;
    int chats_size() const;
    void clear_chats();
    static const int kChatsFieldNumber = 1;
    const ::elegram::Chat &chats(int index) const;
    ::elegram::Chat *mutable_chats(int index);
    ::elegram::Chat *add_chats();
    ::google::protobuf::RepeatedPtrField<::elegram::Chat> *
    mutable_chats();
    const ::google::protobuf::RepeatedPtrField<::elegram::Chat> &
    chats() const;

    // @@protoc_insertion_point(class_scope:elegram.ChatsResponse)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::RepeatedPtrField<::elegram::Chat> chats_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static ChatsResponse *default_instance_;
  };
// -------------------------------------------------------------------

  class Contact : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.Contact) */ {
   public:
    Contact();
    virtual ~Contact();

    Contact(const Contact &from);

    inline Contact &operator=(const Contact &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const Contact &default_instance();

    void Swap(Contact *other);

    // implements Message ----------------------------------------------

    inline Contact *New() const { return New(NULL); }

    Contact *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const Contact &from);
    void MergeFrom(const Contact &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Contact *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint64 user_id = 1;
    void clear_user_id();
    static const int kUserIdFieldNumber = 1;
    ::google::protobuf::uint64 user_id() const;
    void set_user_id(::google::protobuf::uint64 value);

    // optional string name = 2;
    void clear_name();
    static const int kNameFieldNumber = 2;
    const ::std::string &name() const;
    void set_name(const ::std::string &value);
    void set_name(const char *value);
    void set_name(const char *value, size_t size);
    ::std::string *mutable_name();
    ::std::string *release_name();
    void set_allocated_name(::std::string *name);

    // optional string email = 3;
    void clear_email();
    static const int kEmailFieldNumber = 3;
    const ::std::string &email() const;
    void set_email(const ::std::string &value);
    void set_email(const char *value);
    void set_email(const char *value, size_t size);
    ::std::string *mutable_email();
    ::std::string *release_email();
    void set_allocated_email(::std::string *email);

    // @@protoc_insertion_point(class_scope:elegram.Contact)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::uint64 user_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static Contact *default_instance_;
  };
// -------------------------------------------------------------------

  class ContactsResponse
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.ContactsResponse) */ {
   public:
    ContactsResponse();
    virtual ~ContactsResponse();

    ContactsResponse(const ContactsResponse &from);

    inline ContactsResponse &operator=(const ContactsResponse &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const ContactsResponse &default_instance();

    void Swap(ContactsResponse *other);

    // implements Message ----------------------------------------------

    inline ContactsResponse *New() const { return New(NULL); }

    ContactsResponse *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const ContactsResponse &from);
    void MergeFrom(const ContactsResponse &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContactsResponse *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated .elegram.Contact contacts = 1;
    int contacts_size() const;
    void clear_contacts();
    static const int kContactsFieldNumber = 1;
    const ::elegram::Contact &contacts(int index) const;
    ::elegram::Contact *mutable_contacts(int index);
    ::elegram::Contact *add_contacts();
    ::google::protobuf::RepeatedPtrField<::elegram::Contact> *
    mutable_contacts();
    const ::google::protobuf::RepeatedPtrField<::elegram::Contact> &
    contacts() const;

    // @@protoc_insertion_point(class_scope:elegram.ContactsResponse)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::RepeatedPtrField<::elegram::Contact> contacts_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static ContactsResponse *default_instance_;
  };
// -------------------------------------------------------------------

  class MessageToRecieve
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.MessageToRecieve) */ {
   public:
    MessageToRecieve();
    virtual ~MessageToRecieve();

    MessageToRecieve(const MessageToRecieve &from);

    inline MessageToRecieve &operator=(const MessageToRecieve &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const MessageToRecieve &default_instance();

    void Swap(MessageToRecieve *other);

    // implements Message ----------------------------------------------

    inline MessageToRecieve *New() const { return New(NULL); }

    MessageToRecieve *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const MessageToRecieve &from);
    void MergeFrom(const MessageToRecieve &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(MessageToRecieve *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional uint64 sender_id = 1;
    void clear_sender_id();
    static const int kSenderIdFieldNumber = 1;
    ::google::protobuf::uint64 sender_id() const;
    void set_sender_id(::google::protobuf::uint64 value);

    // optional string text = 2;
    void clear_text();
    static const int kTextFieldNumber = 2;
    const ::std::string &text() const;
    void set_text(const ::std::string &value);
    void set_text(const char *value);
    void set_text(const char *value, size_t size);
    ::std::string *mutable_text();
    ::std::string *release_text();
    void set_allocated_text(::std::string *text);

    // @@protoc_insertion_point(class_scope:elegram.MessageToRecieve)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::uint64 sender_id_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static MessageToRecieve *default_instance_;
  };
// -------------------------------------------------------------------

  class MessagesResponse
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.MessagesResponse) */ {
   public:
    MessagesResponse();
    virtual ~MessagesResponse();

    MessagesResponse(const MessagesResponse &from);

    inline MessagesResponse &operator=(const MessagesResponse &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const MessagesResponse &default_instance();

    void Swap(MessagesResponse *other);

    // implements Message ----------------------------------------------

    inline MessagesResponse *New() const { return New(NULL); }

    MessagesResponse *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const MessagesResponse &from);
    void MergeFrom(const MessagesResponse &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(MessagesResponse *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated .elegram.MessageToRecieve messages = 1;
    int messages_size() const;
    void clear_messages();
    static const int kMessagesFieldNumber = 1;
    const ::elegram::MessageToRecieve &messages(int index) const;
    ::elegram::MessageToRecieve *mutable_messages(int index);
    ::elegram::MessageToRecieve *add_messages();
    ::google::protobuf::RepeatedPtrField<::elegram::MessageToRecieve> *
    mutable_messages();
    const ::google::protobuf::RepeatedPtrField<::elegram::MessageToRecieve> &
    messages() const;

    // @@protoc_insertion_point(class_scope:elegram.MessagesResponse)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::RepeatedPtrField<::elegram::MessageToRecieve> messages_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static MessagesResponse *default_instance_;
  };
// -------------------------------------------------------------------

  class Response
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.Response) */ {
   public:
    Response();
    virtual ~Response();

    Response(const Response &from);

    inline Response &operator=(const Response &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const Response &default_instance();

    enum MsgCase {
      kStatusResponse = 1,
      kChatsResponse = 2,
      kContactsResponse = 3,
      kMessagesResponse = 4,
      MSG_NOT_SET = 0,
    };

    void Swap(Response *other);

    // implements Message ----------------------------------------------

    inline Response *New() const { return New(NULL); }

    Response *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const Response &from);
    void MergeFrom(const Response &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Response *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .elegram.StatusResponse status_response = 1;
    bool has_status_response() const;
    void clear_status_response();
    static const int kStatusResponseFieldNumber = 1;
    const ::elegram::StatusResponse &status_response() const;
    ::elegram::StatusResponse *mutable_status_response();
    ::elegram::StatusResponse *release_status_response();
    void set_allocated_status_response(::elegram::StatusResponse *status_response);

    // optional .elegram.ChatsResponse chats_response = 2;
    bool has_chats_response() const;
    void clear_chats_response();
    static const int kChatsResponseFieldNumber = 2;
    const ::elegram::ChatsResponse &chats_response() const;
    ::elegram::ChatsResponse *mutable_chats_response();
    ::elegram::ChatsResponse *release_chats_response();
    void set_allocated_chats_response(::elegram::ChatsResponse *chats_response);

    // optional .elegram.ContactsResponse contacts_response = 3;
    bool has_contacts_response() const;
    void clear_contacts_response();
    static const int kContactsResponseFieldNumber = 3;
    const ::elegram::ContactsResponse &contacts_response() const;
    ::elegram::ContactsResponse *mutable_contacts_response();
    ::elegram::ContactsResponse *release_contacts_response();
    void set_allocated_contacts_response(::elegram::ContactsResponse *contacts_response);

    // optional .elegram.MessagesResponse messages_response = 4;
    bool has_messages_response() const;
    void clear_messages_response();
    static const int kMessagesResponseFieldNumber = 4;
    const ::elegram::MessagesResponse &messages_response() const;
    ::elegram::MessagesResponse *mutable_messages_response();
    ::elegram::MessagesResponse *release_messages_response();
    void set_allocated_messages_response(::elegram::MessagesResponse *messages_response);

    MsgCase msg_case() const;
    // @@protoc_insertion_point(class_scope:elegram.Response)
   private:
    inline void set_has_status_response();
    inline void set_has_chats_response();
    inline void set_has_contacts_response();
    inline void set_has_messages_response();

    inline bool has_msg() const;
    void clear_msg();
    inline void clear_has_msg();

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    union MsgUnion {
      MsgUnion() {}
      ::elegram::StatusResponse *status_response_;
      ::elegram::ChatsResponse *chats_response_;
      ::elegram::ContactsResponse *contacts_response_;
      ::elegram::MessagesResponse *messages_response_;
    } msg_;
    mutable int _cached_size_;
    ::google::protobuf::uint32 _oneof_case_[1];

    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static Response *default_instance_;
  };
// -------------------------------------------------------------------

  class WrappedMessage
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.WrappedMessage) */ {
   public:
    WrappedMessage();
    virtual ~WrappedMessage();

    WrappedMessage(const WrappedMessage &from);

    inline WrappedMessage &operator=(const WrappedMessage &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const WrappedMessage &default_instance();

    enum MsgCase {
      kResponse = 1,
      kRequest = 2,
      MSG_NOT_SET = 0,
    };

    void Swap(WrappedMessage *other);

    // implements Message ----------------------------------------------

    inline WrappedMessage *New() const { return New(NULL); }

    WrappedMessage *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const WrappedMessage &from);
    void MergeFrom(const WrappedMessage &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(WrappedMessage *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional .elegram.Response response = 1;
    bool has_response() const;
    void clear_response();
    static const int kResponseFieldNumber = 1;
    const ::elegram::Response &response() const;
    ::elegram::Response *mutable_response();
    ::elegram::Response *release_response();
    void set_allocated_response(::elegram::Response *response);

    // optional .elegram.Request request = 2;
    bool has_request() const;
    void clear_request();
    static const int kRequestFieldNumber = 2;
    const ::elegram::Request &request() const;
    ::elegram::Request *mutable_request();
    ::elegram::Request *release_request();
    void set_allocated_request(::elegram::Request *request);

    MsgCase msg_case() const;
    // @@protoc_insertion_point(class_scope:elegram.WrappedMessage)
   private:
    inline void set_has_response();
    inline void set_has_request();

    inline bool has_msg() const;
    void clear_msg();
    inline void clear_has_msg();

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    union MsgUnion {
      MsgUnion() {}
      ::elegram::Response *response_;
      ::elegram::Request *request_;
    } msg_;
    mutable int _cached_size_;
    ::google::protobuf::uint32 _oneof_case_[1];

    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static WrappedMessage *default_instance_;
  };
// -------------------------------------------------------------------

  class LengthPrefix
      : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elegram.LengthPrefix) */ {
   public:
    LengthPrefix();
    virtual ~LengthPrefix();

    LengthPrefix(const LengthPrefix &from);

    inline LengthPrefix &operator=(const LengthPrefix &from) {
        CopyFrom(from);
        return *this;
    }

    static const ::google::protobuf::Descriptor *descriptor();
    static const LengthPrefix &default_instance();

    void Swap(LengthPrefix *other);

    // implements Message ----------------------------------------------

    inline LengthPrefix *New() const { return New(NULL); }

    LengthPrefix *New(::google::protobuf::Arena *arena) const;
    void CopyFrom(const ::google::protobuf::Message &from);
    void MergeFrom(const ::google::protobuf::Message &from);
    void CopyFrom(const LengthPrefix &from);
    void MergeFrom(const LengthPrefix &from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *output) const;
    ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(::google::protobuf::uint8 *output) const {
        return InternalSerializeWithCachedSizesToArray(false, output);
    }
    int GetCachedSize() const { return _cached_size_; }
   private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(LengthPrefix *other);
   private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const {
        return _internal_metadata_.arena();
    }
    inline void *MaybeArenaPtr() const {
        return _internal_metadata_.raw_arena_ptr();
    }
   public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional fixed64 length = 1;
    void clear_length();
    static const int kLengthFieldNumber = 1;
    ::google::protobuf::uint64 length() const;
    void set_length(::google::protobuf::uint64 value);

    // @@protoc_insertion_point(class_scope:elegram.LengthPrefix)
   private:

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    bool _is_default_instance_;
    ::google::protobuf::uint64 length_;
    mutable int _cached_size_;
    friend void protobuf_AddDesc_messages_2eproto();
    friend void protobuf_AssignDesc_messages_2eproto();
    friend void protobuf_ShutdownFile_messages_2eproto();

    void InitAsDefaultInstance();
    static LengthPrefix *default_instance_;
  };
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterRequest

// optional string name = 1;
  inline void RegisterRequest::clear_name() {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline const ::std::string &RegisterRequest::name() const {
      // @@protoc_insertion_point(field_get:elegram.RegisterRequest.name)
      return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void RegisterRequest::set_name(const ::std::string &value) {

      name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
      // @@protoc_insertion_point(field_set:elegram.RegisterRequest.name)
  }
  inline void RegisterRequest::set_name(const char *value) {

      name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
      // @@protoc_insertion_point(field_set_char:elegram.RegisterRequest.name)
  }
  inline void RegisterRequest::set_name(const char *value, size_t size) {

      name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                       ::std::string(reinterpret_cast<const char *>(value), size));
      // @@protoc_insertion_point(field_set_pointer:elegram.RegisterRequest.name)
  }
  inline ::std::string *RegisterRequest::mutable_name() {

      // @@protoc_insertion_point(field_mutable:elegram.RegisterRequest.name)
      return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline ::std::string *RegisterRequest::release_name() {
      // @@protoc_insertion_point(field_release:elegram.RegisterRequest.name)

      return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void RegisterRequest::set_allocated_name(::std::string *name) {
      if (name != NULL) {

      } else {

      }
      name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
      // @@protoc_insertion_point(field_set_allocated:elegram.RegisterRequest.name)
  }

// optional string email = 2;
  inline void RegisterRequest::clear_email() {
      email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline const ::std::string &RegisterRequest::email() const {
      // @@protoc_insertion_point(field_get:elegram.RegisterRequest.email)
      return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void RegisterRequest::set_email(const ::std::string &value) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
      // @@protoc_insertion_point(field_set:elegram.RegisterRequest.email)
  }
  inline void RegisterRequest::set_email(const char *value) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
      // @@protoc_insertion_point(field_set_char:elegram.RegisterRequest.email)
  }
  inline void RegisterRequest::set_email(const char *value, size_t size) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                        ::std::string(reinterpret_cast<const char *>(value), size));
      // @@protoc_insertion_point(field_set_pointer:elegram.RegisterRequest.email)
  }
  inline ::std::string *RegisterRequest::mutable_email() {

      // @@protoc_insertion_point(field_mutable:elegram.RegisterRequest.email)
      return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline ::std::string *RegisterRequest::release_email() {
      // @@protoc_insertion_point(field_release:elegram.RegisterRequest.email)

      return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void RegisterRequest::set_allocated_email(::std::string *email) {
      if (email != NULL) {

      } else {

      }
      email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
      // @@protoc_insertion_point(field_set_allocated:elegram.RegisterRequest.email)
  }

// optional string password = 3;
  inline void RegisterRequest::clear_password() {
      password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline const ::std::string &RegisterRequest::password() const {
      // @@protoc_insertion_point(field_get:elegram.RegisterRequest.password)
      return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void RegisterRequest::set_password(const ::std::string &value) {

      password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
      // @@protoc_insertion_point(field_set:elegram.RegisterRequest.password)
  }
  inline void RegisterRequest::set_password(const char *value) {

      password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
      // @@protoc_insertion_point(field_set_char:elegram.RegisterRequest.password)
  }
  inline void RegisterRequest::set_password(const char *value, size_t size) {

      password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                           ::std::string(reinterpret_cast<const char *>(value), size));
      // @@protoc_insertion_point(field_set_pointer:elegram.RegisterRequest.password)
  }
  inline ::std::string *RegisterRequest::mutable_password() {

      // @@protoc_insertion_point(field_mutable:elegram.RegisterRequest.password)
      return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline ::std::string *RegisterRequest::release_password() {
      // @@protoc_insertion_point(field_release:elegram.RegisterRequest.password)

      return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void RegisterRequest::set_allocated_password(::std::string *password) {
      if (password != NULL) {

      } else {

      }
      password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
      // @@protoc_insertion_point(field_set_allocated:elegram.RegisterRequest.password)
  }

// -------------------------------------------------------------------

// LoginRequest

// optional string email = 1;
  inline void LoginRequest::clear_email() {
      email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline const ::std::string &LoginRequest::email() const {
      // @@protoc_insertion_point(field_get:elegram.LoginRequest.email)
      return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void LoginRequest::set_email(const ::std::string &value) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
      // @@protoc_insertion_point(field_set:elegram.LoginRequest.email)
  }
  inline void LoginRequest::set_email(const char *value) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
      // @@protoc_insertion_point(field_set_char:elegram.LoginRequest.email)
  }
  inline void LoginRequest::set_email(const char *value, size_t size) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                        ::std::string(reinterpret_cast<const char *>(value), size));
      // @@protoc_insertion_point(field_set_pointer:elegram.LoginRequest.email)
  }
  inline ::std::string *LoginRequest::mutable_email() {

      // @@protoc_insertion_point(field_mutable:elegram.LoginRequest.email)
      return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline ::std::string *LoginRequest::release_email() {
      // @@protoc_insertion_point(field_release:elegram.LoginRequest.email)

      return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void LoginRequest::set_allocated_email(::std::string *email) {
      if (email != NULL) {

      } else {

      }
      email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
      // @@protoc_insertion_point(field_set_allocated:elegram.LoginRequest.email)
  }

// optional string password = 2;
  inline void LoginRequest::clear_password() {
      password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline const ::std::string &LoginRequest::password() const {
      // @@protoc_insertion_point(field_get:elegram.LoginRequest.password)
      return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void LoginRequest::set_password(const ::std::string &value) {

      password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
      // @@protoc_insertion_point(field_set:elegram.LoginRequest.password)
  }
  inline void LoginRequest::set_password(const char *value) {

      password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
      // @@protoc_insertion_point(field_set_char:elegram.LoginRequest.password)
  }
  inline void LoginRequest::set_password(const char *value, size_t size) {

      password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                           ::std::string(reinterpret_cast<const char *>(value), size));
      // @@protoc_insertion_point(field_set_pointer:elegram.LoginRequest.password)
  }
  inline ::std::string *LoginRequest::mutable_password() {

      // @@protoc_insertion_point(field_mutable:elegram.LoginRequest.password)
      return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline ::std::string *LoginRequest::release_password() {
      // @@protoc_insertion_point(field_release:elegram.LoginRequest.password)

      return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void LoginRequest::set_allocated_password(::std::string *password) {
      if (password != NULL) {

      } else {

      }
      password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
      // @@protoc_insertion_point(field_set_allocated:elegram.LoginRequest.password)
  }

// -------------------------------------------------------------------

// AllMyChatsRequest

// -------------------------------------------------------------------

// AllMyContactsRequest

// -------------------------------------------------------------------

// MessagesRequest

// optional uint64 chat_id = 1;
  inline void MessagesRequest::clear_chat_id() {
      chat_id_ = GOOGLE_ULONGLONG(0);
  }
  inline ::google::protobuf::uint64 MessagesRequest::chat_id() const {
      // @@protoc_insertion_point(field_get:elegram.MessagesRequest.chat_id)
      return chat_id_;
  }
  inline void MessagesRequest::set_chat_id(::google::protobuf::uint64 value) {

      chat_id_ = value;
      // @@protoc_insertion_point(field_set:elegram.MessagesRequest.chat_id)
  }

// -------------------------------------------------------------------

// MessageToSend

// optional uint64 chat_id = 1;
  inline void MessageToSend::clear_chat_id() {
      chat_id_ = GOOGLE_ULONGLONG(0);
  }
  inline ::google::protobuf::uint64 MessageToSend::chat_id() const {
      // @@protoc_insertion_point(field_get:elegram.MessageToSend.chat_id)
      return chat_id_;
  }
  inline void MessageToSend::set_chat_id(::google::protobuf::uint64 value) {

      chat_id_ = value;
      // @@protoc_insertion_point(field_set:elegram.MessageToSend.chat_id)
  }

// optional string text = 2;
  inline void MessageToSend::clear_text() {
      text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline const ::std::string &MessageToSend::text() const {
      // @@protoc_insertion_point(field_get:elegram.MessageToSend.text)
      return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void MessageToSend::set_text(const ::std::string &value) {

      text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
      // @@protoc_insertion_point(field_set:elegram.MessageToSend.text)
  }
  inline void MessageToSend::set_text(const char *value) {

      text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
      // @@protoc_insertion_point(field_set_char:elegram.MessageToSend.text)
  }
  inline void MessageToSend::set_text(const char *value, size_t size) {

      text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                       ::std::string(reinterpret_cast<const char *>(value), size));
      // @@protoc_insertion_point(field_set_pointer:elegram.MessageToSend.text)
  }
  inline ::std::string *MessageToSend::mutable_text() {

      // @@protoc_insertion_point(field_mutable:elegram.MessageToSend.text)
      return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline ::std::string *MessageToSend::release_text() {
      // @@protoc_insertion_point(field_release:elegram.MessageToSend.text)

      return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void MessageToSend::set_allocated_text(::std::string *text) {
      if (text != NULL) {

      } else {

      }
      text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
      // @@protoc_insertion_point(field_set_allocated:elegram.MessageToSend.text)
  }

// -------------------------------------------------------------------

// SendMessageRequest

// optional .elegram.MessageToSend mesg = 1;
  inline bool SendMessageRequest::has_mesg() const {
      return !_is_default_instance_ && mesg_ != NULL;
  }
  inline void SendMessageRequest::clear_mesg() {
      if (GetArenaNoVirtual() == NULL && mesg_ != NULL) delete mesg_;
      mesg_ = NULL;
  }
  inline const ::elegram::MessageToSend &SendMessageRequest::mesg() const {
      // @@protoc_insertion_point(field_get:elegram.SendMessageRequest.mesg)
      return mesg_ != NULL ? *mesg_ : *default_instance_->mesg_;
  }
  inline ::elegram::MessageToSend *SendMessageRequest::mutable_mesg() {

      if (mesg_ == NULL) {
          mesg_ = new ::elegram::MessageToSend;
      }
      // @@protoc_insertion_point(field_mutable:elegram.SendMessageRequest.mesg)
      return mesg_;
  }
  inline ::elegram::MessageToSend *SendMessageRequest::release_mesg() {
      // @@protoc_insertion_point(field_release:elegram.SendMessageRequest.mesg)

      ::elegram::MessageToSend *temp = mesg_;
      mesg_ = NULL;
      return temp;
  }
  inline void SendMessageRequest::set_allocated_mesg(::elegram::MessageToSend *mesg) {
      delete mesg_;
      mesg_ = mesg;
      if (mesg) {

      } else {

      }
      // @@protoc_insertion_point(field_set_allocated:elegram.SendMessageRequest.mesg)
  }

// -------------------------------------------------------------------

// AddContactRequest

// optional string email = 1;
  inline void AddContactRequest::clear_email() {
      email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline const ::std::string &AddContactRequest::email() const {
      // @@protoc_insertion_point(field_get:elegram.AddContactRequest.email)
      return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void AddContactRequest::set_email(const ::std::string &value) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
      // @@protoc_insertion_point(field_set:elegram.AddContactRequest.email)
  }
  inline void AddContactRequest::set_email(const char *value) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
      // @@protoc_insertion_point(field_set_char:elegram.AddContactRequest.email)
  }
  inline void AddContactRequest::set_email(const char *value, size_t size) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                        ::std::string(reinterpret_cast<const char *>(value), size));
      // @@protoc_insertion_point(field_set_pointer:elegram.AddContactRequest.email)
  }
  inline ::std::string *AddContactRequest::mutable_email() {

      // @@protoc_insertion_point(field_mutable:elegram.AddContactRequest.email)
      return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline ::std::string *AddContactRequest::release_email() {
      // @@protoc_insertion_point(field_release:elegram.AddContactRequest.email)

      return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void AddContactRequest::set_allocated_email(::std::string *email) {
      if (email != NULL) {

      } else {

      }
      email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
      // @@protoc_insertion_point(field_set_allocated:elegram.AddContactRequest.email)
  }

// -------------------------------------------------------------------

// Request

// optional .elegram.RegisterRequest register_request = 1;
  inline bool Request::has_register_request() const {
      return msg_case() == kRegisterRequest;
  }
  inline void Request::set_has_register_request() {
      _oneof_case_[0] = kRegisterRequest;
  }
  inline void Request::clear_register_request() {
      if (has_register_request()) {
          delete msg_.register_request_;
          clear_has_msg();
      }
  }
  inline const ::elegram::RegisterRequest &Request::register_request() const {
      // @@protoc_insertion_point(field_get:elegram.Request.register_request)
      return has_register_request()
             ? *msg_.register_request_
             : ::elegram::RegisterRequest::default_instance();
  }
  inline ::elegram::RegisterRequest *Request::mutable_register_request() {
      if (!has_register_request()) {
          clear_msg();
          set_has_register_request();
          msg_.register_request_ = new ::elegram::RegisterRequest;
      }
      // @@protoc_insertion_point(field_mutable:elegram.Request.register_request)
      return msg_.register_request_;
  }
  inline ::elegram::RegisterRequest *Request::release_register_request() {
      // @@protoc_insertion_point(field_release:elegram.Request.register_request)
      if (has_register_request()) {
          clear_has_msg();
          ::elegram::RegisterRequest *temp = msg_.register_request_;
          msg_.register_request_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void Request::set_allocated_register_request(::elegram::RegisterRequest *register_request) {
      clear_msg();
      if (register_request) {
          set_has_register_request();
          msg_.register_request_ = register_request;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.Request.register_request)
  }

// optional .elegram.LoginRequest login_request = 2;
  inline bool Request::has_login_request() const {
      return msg_case() == kLoginRequest;
  }
  inline void Request::set_has_login_request() {
      _oneof_case_[0] = kLoginRequest;
  }
  inline void Request::clear_login_request() {
      if (has_login_request()) {
          delete msg_.login_request_;
          clear_has_msg();
      }
  }
  inline const ::elegram::LoginRequest &Request::login_request() const {
      // @@protoc_insertion_point(field_get:elegram.Request.login_request)
      return has_login_request()
             ? *msg_.login_request_
             : ::elegram::LoginRequest::default_instance();
  }
  inline ::elegram::LoginRequest *Request::mutable_login_request() {
      if (!has_login_request()) {
          clear_msg();
          set_has_login_request();
          msg_.login_request_ = new ::elegram::LoginRequest;
      }
      // @@protoc_insertion_point(field_mutable:elegram.Request.login_request)
      return msg_.login_request_;
  }
  inline ::elegram::LoginRequest *Request::release_login_request() {
      // @@protoc_insertion_point(field_release:elegram.Request.login_request)
      if (has_login_request()) {
          clear_has_msg();
          ::elegram::LoginRequest *temp = msg_.login_request_;
          msg_.login_request_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void Request::set_allocated_login_request(::elegram::LoginRequest *login_request) {
      clear_msg();
      if (login_request) {
          set_has_login_request();
          msg_.login_request_ = login_request;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.Request.login_request)
  }

// optional .elegram.AllMyChatsRequest chats_request = 3;
  inline bool Request::has_chats_request() const {
      return msg_case() == kChatsRequest;
  }
  inline void Request::set_has_chats_request() {
      _oneof_case_[0] = kChatsRequest;
  }
  inline void Request::clear_chats_request() {
      if (has_chats_request()) {
          delete msg_.chats_request_;
          clear_has_msg();
      }
  }
  inline const ::elegram::AllMyChatsRequest &Request::chats_request() const {
      // @@protoc_insertion_point(field_get:elegram.Request.chats_request)
      return has_chats_request()
             ? *msg_.chats_request_
             : ::elegram::AllMyChatsRequest::default_instance();
  }
  inline ::elegram::AllMyChatsRequest *Request::mutable_chats_request() {
      if (!has_chats_request()) {
          clear_msg();
          set_has_chats_request();
          msg_.chats_request_ = new ::elegram::AllMyChatsRequest;
      }
      // @@protoc_insertion_point(field_mutable:elegram.Request.chats_request)
      return msg_.chats_request_;
  }
  inline ::elegram::AllMyChatsRequest *Request::release_chats_request() {
      // @@protoc_insertion_point(field_release:elegram.Request.chats_request)
      if (has_chats_request()) {
          clear_has_msg();
          ::elegram::AllMyChatsRequest *temp = msg_.chats_request_;
          msg_.chats_request_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void Request::set_allocated_chats_request(::elegram::AllMyChatsRequest *chats_request) {
      clear_msg();
      if (chats_request) {
          set_has_chats_request();
          msg_.chats_request_ = chats_request;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.Request.chats_request)
  }

// optional .elegram.AllMyContactsRequest contacts_request = 4;
  inline bool Request::has_contacts_request() const {
      return msg_case() == kContactsRequest;
  }
  inline void Request::set_has_contacts_request() {
      _oneof_case_[0] = kContactsRequest;
  }
  inline void Request::clear_contacts_request() {
      if (has_contacts_request()) {
          delete msg_.contacts_request_;
          clear_has_msg();
      }
  }
  inline const ::elegram::AllMyContactsRequest &Request::contacts_request() const {
      // @@protoc_insertion_point(field_get:elegram.Request.contacts_request)
      return has_contacts_request()
             ? *msg_.contacts_request_
             : ::elegram::AllMyContactsRequest::default_instance();
  }
  inline ::elegram::AllMyContactsRequest *Request::mutable_contacts_request() {
      if (!has_contacts_request()) {
          clear_msg();
          set_has_contacts_request();
          msg_.contacts_request_ = new ::elegram::AllMyContactsRequest;
      }
      // @@protoc_insertion_point(field_mutable:elegram.Request.contacts_request)
      return msg_.contacts_request_;
  }
  inline ::elegram::AllMyContactsRequest *Request::release_contacts_request() {
      // @@protoc_insertion_point(field_release:elegram.Request.contacts_request)
      if (has_contacts_request()) {
          clear_has_msg();
          ::elegram::AllMyContactsRequest *temp = msg_.contacts_request_;
          msg_.contacts_request_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void Request::set_allocated_contacts_request(::elegram::AllMyContactsRequest *contacts_request) {
      clear_msg();
      if (contacts_request) {
          set_has_contacts_request();
          msg_.contacts_request_ = contacts_request;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.Request.contacts_request)
  }

// optional .elegram.MessagesRequest messages_request = 5;
  inline bool Request::has_messages_request() const {
      return msg_case() == kMessagesRequest;
  }
  inline void Request::set_has_messages_request() {
      _oneof_case_[0] = kMessagesRequest;
  }
  inline void Request::clear_messages_request() {
      if (has_messages_request()) {
          delete msg_.messages_request_;
          clear_has_msg();
      }
  }
  inline const ::elegram::MessagesRequest &Request::messages_request() const {
      // @@protoc_insertion_point(field_get:elegram.Request.messages_request)
      return has_messages_request()
             ? *msg_.messages_request_
             : ::elegram::MessagesRequest::default_instance();
  }
  inline ::elegram::MessagesRequest *Request::mutable_messages_request() {
      if (!has_messages_request()) {
          clear_msg();
          set_has_messages_request();
          msg_.messages_request_ = new ::elegram::MessagesRequest;
      }
      // @@protoc_insertion_point(field_mutable:elegram.Request.messages_request)
      return msg_.messages_request_;
  }
  inline ::elegram::MessagesRequest *Request::release_messages_request() {
      // @@protoc_insertion_point(field_release:elegram.Request.messages_request)
      if (has_messages_request()) {
          clear_has_msg();
          ::elegram::MessagesRequest *temp = msg_.messages_request_;
          msg_.messages_request_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void Request::set_allocated_messages_request(::elegram::MessagesRequest *messages_request) {
      clear_msg();
      if (messages_request) {
          set_has_messages_request();
          msg_.messages_request_ = messages_request;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.Request.messages_request)
  }

// optional .elegram.SendMessageRequest send_mesg_request = 6;
  inline bool Request::has_send_mesg_request() const {
      return msg_case() == kSendMesgRequest;
  }
  inline void Request::set_has_send_mesg_request() {
      _oneof_case_[0] = kSendMesgRequest;
  }
  inline void Request::clear_send_mesg_request() {
      if (has_send_mesg_request()) {
          delete msg_.send_mesg_request_;
          clear_has_msg();
      }
  }
  inline const ::elegram::SendMessageRequest &Request::send_mesg_request() const {
      // @@protoc_insertion_point(field_get:elegram.Request.send_mesg_request)
      return has_send_mesg_request()
             ? *msg_.send_mesg_request_
             : ::elegram::SendMessageRequest::default_instance();
  }
  inline ::elegram::SendMessageRequest *Request::mutable_send_mesg_request() {
      if (!has_send_mesg_request()) {
          clear_msg();
          set_has_send_mesg_request();
          msg_.send_mesg_request_ = new ::elegram::SendMessageRequest;
      }
      // @@protoc_insertion_point(field_mutable:elegram.Request.send_mesg_request)
      return msg_.send_mesg_request_;
  }
  inline ::elegram::SendMessageRequest *Request::release_send_mesg_request() {
      // @@protoc_insertion_point(field_release:elegram.Request.send_mesg_request)
      if (has_send_mesg_request()) {
          clear_has_msg();
          ::elegram::SendMessageRequest *temp = msg_.send_mesg_request_;
          msg_.send_mesg_request_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void Request::set_allocated_send_mesg_request(::elegram::SendMessageRequest *send_mesg_request) {
      clear_msg();
      if (send_mesg_request) {
          set_has_send_mesg_request();
          msg_.send_mesg_request_ = send_mesg_request;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.Request.send_mesg_request)
  }

// optional .elegram.AddContactRequest add_contact_request = 7;
  inline bool Request::has_add_contact_request() const {
      return msg_case() == kAddContactRequest;
  }
  inline void Request::set_has_add_contact_request() {
      _oneof_case_[0] = kAddContactRequest;
  }
  inline void Request::clear_add_contact_request() {
      if (has_add_contact_request()) {
          delete msg_.add_contact_request_;
          clear_has_msg();
      }
  }
  inline const ::elegram::AddContactRequest &Request::add_contact_request() const {
      // @@protoc_insertion_point(field_get:elegram.Request.add_contact_request)
      return has_add_contact_request()
             ? *msg_.add_contact_request_
             : ::elegram::AddContactRequest::default_instance();
  }
  inline ::elegram::AddContactRequest *Request::mutable_add_contact_request() {
      if (!has_add_contact_request()) {
          clear_msg();
          set_has_add_contact_request();
          msg_.add_contact_request_ = new ::elegram::AddContactRequest;
      }
      // @@protoc_insertion_point(field_mutable:elegram.Request.add_contact_request)
      return msg_.add_contact_request_;
  }
  inline ::elegram::AddContactRequest *Request::release_add_contact_request() {
      // @@protoc_insertion_point(field_release:elegram.Request.add_contact_request)
      if (has_add_contact_request()) {
          clear_has_msg();
          ::elegram::AddContactRequest *temp = msg_.add_contact_request_;
          msg_.add_contact_request_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void Request::set_allocated_add_contact_request(::elegram::AddContactRequest *add_contact_request) {
      clear_msg();
      if (add_contact_request) {
          set_has_add_contact_request();
          msg_.add_contact_request_ = add_contact_request;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.Request.add_contact_request)
  }

  inline bool Request::has_msg() const {
      return msg_case() != MSG_NOT_SET;
  }
  inline void Request::clear_has_msg() {
      _oneof_case_[0] = MSG_NOT_SET;
  }
  inline Request::MsgCase Request::msg_case() const {
      return Request::MsgCase(_oneof_case_[0]);
  }
// -------------------------------------------------------------------

// StatusResponse

// optional .elegram.StatusResponse.RESULT result = 1;
  inline void StatusResponse::clear_result() {
      result_ = 0;
  }
  inline ::elegram::StatusResponse_RESULT StatusResponse::result() const {
      // @@protoc_insertion_point(field_get:elegram.StatusResponse.result)
      return static_cast< ::elegram::StatusResponse_RESULT >(result_);
  }
  inline void StatusResponse::set_result(::elegram::StatusResponse_RESULT value) {

      result_ = value;
      // @@protoc_insertion_point(field_set:elegram.StatusResponse.result)
  }

// -------------------------------------------------------------------

// Chat

// optional uint64 chat_id = 1;
  inline void Chat::clear_chat_id() {
      chat_id_ = GOOGLE_ULONGLONG(0);
  }
  inline ::google::protobuf::uint64 Chat::chat_id() const {
      // @@protoc_insertion_point(field_get:elegram.Chat.chat_id)
      return chat_id_;
  }
  inline void Chat::set_chat_id(::google::protobuf::uint64 value) {

      chat_id_ = value;
      // @@protoc_insertion_point(field_set:elegram.Chat.chat_id)
  }

// optional string title = 2;
  inline void Chat::clear_title() {
      title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline const ::std::string &Chat::title() const {
      // @@protoc_insertion_point(field_get:elegram.Chat.title)
      return title_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void Chat::set_title(const ::std::string &value) {

      title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
      // @@protoc_insertion_point(field_set:elegram.Chat.title)
  }
  inline void Chat::set_title(const char *value) {

      title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
      // @@protoc_insertion_point(field_set_char:elegram.Chat.title)
  }
  inline void Chat::set_title(const char *value, size_t size) {

      title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                        ::std::string(reinterpret_cast<const char *>(value), size));
      // @@protoc_insertion_point(field_set_pointer:elegram.Chat.title)
  }
  inline ::std::string *Chat::mutable_title() {

      // @@protoc_insertion_point(field_mutable:elegram.Chat.title)
      return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline ::std::string *Chat::release_title() {
      // @@protoc_insertion_point(field_release:elegram.Chat.title)

      return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void Chat::set_allocated_title(::std::string *title) {
      if (title != NULL) {

      } else {

      }
      title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
      // @@protoc_insertion_point(field_set_allocated:elegram.Chat.title)
  }

// -------------------------------------------------------------------

// ChatsResponse

// repeated .elegram.Chat chats = 1;
  inline int ChatsResponse::chats_size() const {
      return chats_.size();
  }
  inline void ChatsResponse::clear_chats() {
      chats_.Clear();
  }
  inline const ::elegram::Chat &ChatsResponse::chats(int index) const {
      // @@protoc_insertion_point(field_get:elegram.ChatsResponse.chats)
      return chats_.Get(index);
  }
  inline ::elegram::Chat *ChatsResponse::mutable_chats(int index) {
      // @@protoc_insertion_point(field_mutable:elegram.ChatsResponse.chats)
      return chats_.Mutable(index);
  }
  inline ::elegram::Chat *ChatsResponse::add_chats() {
      // @@protoc_insertion_point(field_add:elegram.ChatsResponse.chats)
      return chats_.Add();
  }
  inline ::google::protobuf::RepeatedPtrField<::elegram::Chat> *
  ChatsResponse::mutable_chats() {
      // @@protoc_insertion_point(field_mutable_list:elegram.ChatsResponse.chats)
      return &chats_;
  }
  inline const ::google::protobuf::RepeatedPtrField<::elegram::Chat> &
  ChatsResponse::chats() const {
      // @@protoc_insertion_point(field_list:elegram.ChatsResponse.chats)
      return chats_;
  }

// -------------------------------------------------------------------

// Contact

// optional uint64 user_id = 1;
  inline void Contact::clear_user_id() {
      user_id_ = GOOGLE_ULONGLONG(0);
  }
  inline ::google::protobuf::uint64 Contact::user_id() const {
      // @@protoc_insertion_point(field_get:elegram.Contact.user_id)
      return user_id_;
  }
  inline void Contact::set_user_id(::google::protobuf::uint64 value) {

      user_id_ = value;
      // @@protoc_insertion_point(field_set:elegram.Contact.user_id)
  }

// optional string name = 2;
  inline void Contact::clear_name() {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline const ::std::string &Contact::name() const {
      // @@protoc_insertion_point(field_get:elegram.Contact.name)
      return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void Contact::set_name(const ::std::string &value) {

      name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
      // @@protoc_insertion_point(field_set:elegram.Contact.name)
  }
  inline void Contact::set_name(const char *value) {

      name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
      // @@protoc_insertion_point(field_set_char:elegram.Contact.name)
  }
  inline void Contact::set_name(const char *value, size_t size) {

      name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                       ::std::string(reinterpret_cast<const char *>(value), size));
      // @@protoc_insertion_point(field_set_pointer:elegram.Contact.name)
  }
  inline ::std::string *Contact::mutable_name() {

      // @@protoc_insertion_point(field_mutable:elegram.Contact.name)
      return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline ::std::string *Contact::release_name() {
      // @@protoc_insertion_point(field_release:elegram.Contact.name)

      return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void Contact::set_allocated_name(::std::string *name) {
      if (name != NULL) {

      } else {

      }
      name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
      // @@protoc_insertion_point(field_set_allocated:elegram.Contact.name)
  }

// optional string email = 3;
  inline void Contact::clear_email() {
      email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline const ::std::string &Contact::email() const {
      // @@protoc_insertion_point(field_get:elegram.Contact.email)
      return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void Contact::set_email(const ::std::string &value) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
      // @@protoc_insertion_point(field_set:elegram.Contact.email)
  }
  inline void Contact::set_email(const char *value) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
      // @@protoc_insertion_point(field_set_char:elegram.Contact.email)
  }
  inline void Contact::set_email(const char *value, size_t size) {

      email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                        ::std::string(reinterpret_cast<const char *>(value), size));
      // @@protoc_insertion_point(field_set_pointer:elegram.Contact.email)
  }
  inline ::std::string *Contact::mutable_email() {

      // @@protoc_insertion_point(field_mutable:elegram.Contact.email)
      return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline ::std::string *Contact::release_email() {
      // @@protoc_insertion_point(field_release:elegram.Contact.email)

      return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void Contact::set_allocated_email(::std::string *email) {
      if (email != NULL) {

      } else {

      }
      email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
      // @@protoc_insertion_point(field_set_allocated:elegram.Contact.email)
  }

// -------------------------------------------------------------------

// ContactsResponse

// repeated .elegram.Contact contacts = 1;
  inline int ContactsResponse::contacts_size() const {
      return contacts_.size();
  }
  inline void ContactsResponse::clear_contacts() {
      contacts_.Clear();
  }
  inline const ::elegram::Contact &ContactsResponse::contacts(int index) const {
      // @@protoc_insertion_point(field_get:elegram.ContactsResponse.contacts)
      return contacts_.Get(index);
  }
  inline ::elegram::Contact *ContactsResponse::mutable_contacts(int index) {
      // @@protoc_insertion_point(field_mutable:elegram.ContactsResponse.contacts)
      return contacts_.Mutable(index);
  }
  inline ::elegram::Contact *ContactsResponse::add_contacts() {
      // @@protoc_insertion_point(field_add:elegram.ContactsResponse.contacts)
      return contacts_.Add();
  }
  inline ::google::protobuf::RepeatedPtrField<::elegram::Contact> *
  ContactsResponse::mutable_contacts() {
      // @@protoc_insertion_point(field_mutable_list:elegram.ContactsResponse.contacts)
      return &contacts_;
  }
  inline const ::google::protobuf::RepeatedPtrField<::elegram::Contact> &
  ContactsResponse::contacts() const {
      // @@protoc_insertion_point(field_list:elegram.ContactsResponse.contacts)
      return contacts_;
  }

// -------------------------------------------------------------------

// MessageToRecieve

// optional uint64 sender_id = 1;
  inline void MessageToRecieve::clear_sender_id() {
      sender_id_ = GOOGLE_ULONGLONG(0);
  }
  inline ::google::protobuf::uint64 MessageToRecieve::sender_id() const {
      // @@protoc_insertion_point(field_get:elegram.MessageToRecieve.sender_id)
      return sender_id_;
  }
  inline void MessageToRecieve::set_sender_id(::google::protobuf::uint64 value) {

      sender_id_ = value;
      // @@protoc_insertion_point(field_set:elegram.MessageToRecieve.sender_id)
  }

// optional string text = 2;
  inline void MessageToRecieve::clear_text() {
      text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline const ::std::string &MessageToRecieve::text() const {
      // @@protoc_insertion_point(field_get:elegram.MessageToRecieve.text)
      return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void MessageToRecieve::set_text(const ::std::string &value) {

      text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
      // @@protoc_insertion_point(field_set:elegram.MessageToRecieve.text)
  }
  inline void MessageToRecieve::set_text(const char *value) {

      text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
      // @@protoc_insertion_point(field_set_char:elegram.MessageToRecieve.text)
  }
  inline void MessageToRecieve::set_text(const char *value, size_t size) {

      text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                       ::std::string(reinterpret_cast<const char *>(value), size));
      // @@protoc_insertion_point(field_set_pointer:elegram.MessageToRecieve.text)
  }
  inline ::std::string *MessageToRecieve::mutable_text() {

      // @@protoc_insertion_point(field_mutable:elegram.MessageToRecieve.text)
      return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline ::std::string *MessageToRecieve::release_text() {
      // @@protoc_insertion_point(field_release:elegram.MessageToRecieve.text)

      return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  inline void MessageToRecieve::set_allocated_text(::std::string *text) {
      if (text != NULL) {

      } else {

      }
      text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
      // @@protoc_insertion_point(field_set_allocated:elegram.MessageToRecieve.text)
  }

// -------------------------------------------------------------------

// MessagesResponse

// repeated .elegram.MessageToRecieve messages = 1;
  inline int MessagesResponse::messages_size() const {
      return messages_.size();
  }
  inline void MessagesResponse::clear_messages() {
      messages_.Clear();
  }
  inline const ::elegram::MessageToRecieve &MessagesResponse::messages(int index) const {
      // @@protoc_insertion_point(field_get:elegram.MessagesResponse.messages)
      return messages_.Get(index);
  }
  inline ::elegram::MessageToRecieve *MessagesResponse::mutable_messages(int index) {
      // @@protoc_insertion_point(field_mutable:elegram.MessagesResponse.messages)
      return messages_.Mutable(index);
  }
  inline ::elegram::MessageToRecieve *MessagesResponse::add_messages() {
      // @@protoc_insertion_point(field_add:elegram.MessagesResponse.messages)
      return messages_.Add();
  }
  inline ::google::protobuf::RepeatedPtrField<::elegram::MessageToRecieve> *
  MessagesResponse::mutable_messages() {
      // @@protoc_insertion_point(field_mutable_list:elegram.MessagesResponse.messages)
      return &messages_;
  }
  inline const ::google::protobuf::RepeatedPtrField<::elegram::MessageToRecieve> &
  MessagesResponse::messages() const {
      // @@protoc_insertion_point(field_list:elegram.MessagesResponse.messages)
      return messages_;
  }

// -------------------------------------------------------------------

// Response

// optional .elegram.StatusResponse status_response = 1;
  inline bool Response::has_status_response() const {
      return msg_case() == kStatusResponse;
  }
  inline void Response::set_has_status_response() {
      _oneof_case_[0] = kStatusResponse;
  }
  inline void Response::clear_status_response() {
      if (has_status_response()) {
          delete msg_.status_response_;
          clear_has_msg();
      }
  }
  inline const ::elegram::StatusResponse &Response::status_response() const {
      // @@protoc_insertion_point(field_get:elegram.Response.status_response)
      return has_status_response()
             ? *msg_.status_response_
             : ::elegram::StatusResponse::default_instance();
  }
  inline ::elegram::StatusResponse *Response::mutable_status_response() {
      if (!has_status_response()) {
          clear_msg();
          set_has_status_response();
          msg_.status_response_ = new ::elegram::StatusResponse;
      }
      // @@protoc_insertion_point(field_mutable:elegram.Response.status_response)
      return msg_.status_response_;
  }
  inline ::elegram::StatusResponse *Response::release_status_response() {
      // @@protoc_insertion_point(field_release:elegram.Response.status_response)
      if (has_status_response()) {
          clear_has_msg();
          ::elegram::StatusResponse *temp = msg_.status_response_;
          msg_.status_response_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void Response::set_allocated_status_response(::elegram::StatusResponse *status_response) {
      clear_msg();
      if (status_response) {
          set_has_status_response();
          msg_.status_response_ = status_response;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.Response.status_response)
  }

// optional .elegram.ChatsResponse chats_response = 2;
  inline bool Response::has_chats_response() const {
      return msg_case() == kChatsResponse;
  }
  inline void Response::set_has_chats_response() {
      _oneof_case_[0] = kChatsResponse;
  }
  inline void Response::clear_chats_response() {
      if (has_chats_response()) {
          delete msg_.chats_response_;
          clear_has_msg();
      }
  }
  inline const ::elegram::ChatsResponse &Response::chats_response() const {
      // @@protoc_insertion_point(field_get:elegram.Response.chats_response)
      return has_chats_response()
             ? *msg_.chats_response_
             : ::elegram::ChatsResponse::default_instance();
  }
  inline ::elegram::ChatsResponse *Response::mutable_chats_response() {
      if (!has_chats_response()) {
          clear_msg();
          set_has_chats_response();
          msg_.chats_response_ = new ::elegram::ChatsResponse;
      }
      // @@protoc_insertion_point(field_mutable:elegram.Response.chats_response)
      return msg_.chats_response_;
  }
  inline ::elegram::ChatsResponse *Response::release_chats_response() {
      // @@protoc_insertion_point(field_release:elegram.Response.chats_response)
      if (has_chats_response()) {
          clear_has_msg();
          ::elegram::ChatsResponse *temp = msg_.chats_response_;
          msg_.chats_response_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void Response::set_allocated_chats_response(::elegram::ChatsResponse *chats_response) {
      clear_msg();
      if (chats_response) {
          set_has_chats_response();
          msg_.chats_response_ = chats_response;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.Response.chats_response)
  }

// optional .elegram.ContactsResponse contacts_response = 3;
  inline bool Response::has_contacts_response() const {
      return msg_case() == kContactsResponse;
  }
  inline void Response::set_has_contacts_response() {
      _oneof_case_[0] = kContactsResponse;
  }
  inline void Response::clear_contacts_response() {
      if (has_contacts_response()) {
          delete msg_.contacts_response_;
          clear_has_msg();
      }
  }
  inline const ::elegram::ContactsResponse &Response::contacts_response() const {
      // @@protoc_insertion_point(field_get:elegram.Response.contacts_response)
      return has_contacts_response()
             ? *msg_.contacts_response_
             : ::elegram::ContactsResponse::default_instance();
  }
  inline ::elegram::ContactsResponse *Response::mutable_contacts_response() {
      if (!has_contacts_response()) {
          clear_msg();
          set_has_contacts_response();
          msg_.contacts_response_ = new ::elegram::ContactsResponse;
      }
      // @@protoc_insertion_point(field_mutable:elegram.Response.contacts_response)
      return msg_.contacts_response_;
  }
  inline ::elegram::ContactsResponse *Response::release_contacts_response() {
      // @@protoc_insertion_point(field_release:elegram.Response.contacts_response)
      if (has_contacts_response()) {
          clear_has_msg();
          ::elegram::ContactsResponse *temp = msg_.contacts_response_;
          msg_.contacts_response_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void Response::set_allocated_contacts_response(::elegram::ContactsResponse *contacts_response) {
      clear_msg();
      if (contacts_response) {
          set_has_contacts_response();
          msg_.contacts_response_ = contacts_response;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.Response.contacts_response)
  }

// optional .elegram.MessagesResponse messages_response = 4;
  inline bool Response::has_messages_response() const {
      return msg_case() == kMessagesResponse;
  }
  inline void Response::set_has_messages_response() {
      _oneof_case_[0] = kMessagesResponse;
  }
  inline void Response::clear_messages_response() {
      if (has_messages_response()) {
          delete msg_.messages_response_;
          clear_has_msg();
      }
  }
  inline const ::elegram::MessagesResponse &Response::messages_response() const {
      // @@protoc_insertion_point(field_get:elegram.Response.messages_response)
      return has_messages_response()
             ? *msg_.messages_response_
             : ::elegram::MessagesResponse::default_instance();
  }
  inline ::elegram::MessagesResponse *Response::mutable_messages_response() {
      if (!has_messages_response()) {
          clear_msg();
          set_has_messages_response();
          msg_.messages_response_ = new ::elegram::MessagesResponse;
      }
      // @@protoc_insertion_point(field_mutable:elegram.Response.messages_response)
      return msg_.messages_response_;
  }
  inline ::elegram::MessagesResponse *Response::release_messages_response() {
      // @@protoc_insertion_point(field_release:elegram.Response.messages_response)
      if (has_messages_response()) {
          clear_has_msg();
          ::elegram::MessagesResponse *temp = msg_.messages_response_;
          msg_.messages_response_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void Response::set_allocated_messages_response(::elegram::MessagesResponse *messages_response) {
      clear_msg();
      if (messages_response) {
          set_has_messages_response();
          msg_.messages_response_ = messages_response;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.Response.messages_response)
  }

  inline bool Response::has_msg() const {
      return msg_case() != MSG_NOT_SET;
  }
  inline void Response::clear_has_msg() {
      _oneof_case_[0] = MSG_NOT_SET;
  }
  inline Response::MsgCase Response::msg_case() const {
      return Response::MsgCase(_oneof_case_[0]);
  }
// -------------------------------------------------------------------

// WrappedMessage

// optional .elegram.Response response = 1;
  inline bool WrappedMessage::has_response() const {
      return msg_case() == kResponse;
  }
  inline void WrappedMessage::set_has_response() {
      _oneof_case_[0] = kResponse;
  }
  inline void WrappedMessage::clear_response() {
      if (has_response()) {
          delete msg_.response_;
          clear_has_msg();
      }
  }
  inline const ::elegram::Response &WrappedMessage::response() const {
      // @@protoc_insertion_point(field_get:elegram.WrappedMessage.response)
      return has_response()
             ? *msg_.response_
             : ::elegram::Response::default_instance();
  }
  inline ::elegram::Response *WrappedMessage::mutable_response() {
      if (!has_response()) {
          clear_msg();
          set_has_response();
          msg_.response_ = new ::elegram::Response;
      }
      // @@protoc_insertion_point(field_mutable:elegram.WrappedMessage.response)
      return msg_.response_;
  }
  inline ::elegram::Response *WrappedMessage::release_response() {
      // @@protoc_insertion_point(field_release:elegram.WrappedMessage.response)
      if (has_response()) {
          clear_has_msg();
          ::elegram::Response *temp = msg_.response_;
          msg_.response_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void WrappedMessage::set_allocated_response(::elegram::Response *response) {
      clear_msg();
      if (response) {
          set_has_response();
          msg_.response_ = response;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.WrappedMessage.response)
  }

// optional .elegram.Request request = 2;
  inline bool WrappedMessage::has_request() const {
      return msg_case() == kRequest;
  }
  inline void WrappedMessage::set_has_request() {
      _oneof_case_[0] = kRequest;
  }
  inline void WrappedMessage::clear_request() {
      if (has_request()) {
          delete msg_.request_;
          clear_has_msg();
      }
  }
  inline const ::elegram::Request &WrappedMessage::request() const {
      // @@protoc_insertion_point(field_get:elegram.WrappedMessage.request)
      return has_request()
             ? *msg_.request_
             : ::elegram::Request::default_instance();
  }
  inline ::elegram::Request *WrappedMessage::mutable_request() {
      if (!has_request()) {
          clear_msg();
          set_has_request();
          msg_.request_ = new ::elegram::Request;
      }
      // @@protoc_insertion_point(field_mutable:elegram.WrappedMessage.request)
      return msg_.request_;
  }
  inline ::elegram::Request *WrappedMessage::release_request() {
      // @@protoc_insertion_point(field_release:elegram.WrappedMessage.request)
      if (has_request()) {
          clear_has_msg();
          ::elegram::Request *temp = msg_.request_;
          msg_.request_ = NULL;
          return temp;
      } else {
          return NULL;
      }
  }
  inline void WrappedMessage::set_allocated_request(::elegram::Request *request) {
      clear_msg();
      if (request) {
          set_has_request();
          msg_.request_ = request;
      }
      // @@protoc_insertion_point(field_set_allocated:elegram.WrappedMessage.request)
  }

  inline bool WrappedMessage::has_msg() const {
      return msg_case() != MSG_NOT_SET;
  }
  inline void WrappedMessage::clear_has_msg() {
      _oneof_case_[0] = MSG_NOT_SET;
  }
  inline WrappedMessage::MsgCase WrappedMessage::msg_case() const {
      return WrappedMessage::MsgCase(_oneof_case_[0]);
  }
// -------------------------------------------------------------------

// LengthPrefix

// optional fixed64 length = 1;
  inline void LengthPrefix::clear_length() {
      length_ = GOOGLE_ULONGLONG(0);
  }
  inline ::google::protobuf::uint64 LengthPrefix::length() const {
      // @@protoc_insertion_point(field_get:elegram.LengthPrefix.length)
      return length_;
  }
  inline void LengthPrefix::set_length(::google::protobuf::uint64 value) {

      length_ = value;
      // @@protoc_insertion_point(field_set:elegram.LengthPrefix.length)
  }

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace elegram

#ifndef SWIG
namespace google {
  namespace protobuf {

    template<>
    struct is_proto_enum<::elegram::StatusResponse_RESULT> : ::google::protobuf::internal::true_type {};
    template<>
    inline const EnumDescriptor *GetEnumDescriptor<::elegram::StatusResponse_RESULT>() {
        return ::elegram::StatusResponse_RESULT_descriptor();
    }

  }  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
